特权级机制
==================

.. toctree::
   :hidden:
   :maxdepth: 5

本节导读
--------------

为了保护我们的批处理操作系统不受到出错应用程序的影响并全程稳定工作，单凭软件实现是很难做到的，而是需要 CPU 提供一种特权级隔离机制，使 CPU 在执行应用程序和操作系统内核的指令时处于不同的特权级。本节主要介绍了特权级机制的软硬件设计思路，以及 LoongArch 的特权级架构，包括特权指令的描述。

特权级的软硬件协同设计
--------------------------------------

实现特权级机制的根本原因是应用程序运行的安全性不可充分信任。在上一章里，操作系统以库的形式和应用紧密连接在一起，构成一个整体来执行。随着应用需求的增加，操作系统的体积也越来越大；同时应用自身也会越来越复杂。由于操作系统会被频繁访问，来给多个应用提供服务，所以它可能的错误会比较快地被发现。但应用自身的错误可能就不会很快发现。由于二者通过编译器形成一个单一执行程序来执行，导致即使是应用程序本身的问题，也会让操作系统受到连累，从而可能导致整个计算机系统都不可用了。

所以，计算机科学家和工程师就想到一个方法，让相对安全可靠的操作系统运行在一个硬件保护的安全执行环境中，不受到应用程序的破坏；而让应用程序运行在另外一个无法破坏操作系统的受限执行环境中。

为确保操作系统的安全，对应用程序而言，需要限制的主要有两个方面：

- 应用程序不能访问任意的地址空间（这个在第四章会进一步讲解，本章不会涉及）
- 应用程序不能执行某些可能破坏计算机系统的指令（本章的重点）

假设有了这样的限制，我们还需要确保应用程序能够得到操作系统的服务，即应用程序和操作系统还需要有交互的手段。使得低特权级软件只能做高特权级软件允许它做的，且超出低特权级软件能力的功能必须寻求高特权级软件的帮助。这样，高特权级软件（操作系统）就成为低特权级软件（一般应用）的软件执行环境的重要组成部分。

为了实现这样的特权级机制，需要进行软硬件协同设计。一个比较简洁的方法就是，处理器设置两个不同安全等级的执行环境：用户态特权级的执行环境和内核态特权级的执行环境。且明确指出可能破坏计算机系统的内核态特权级指令子集，规定内核态特权级指令子集中的指令只能在内核态特权级的执行环境中执行。处理器在执行指令前会进行特权级安全检查，如果在用户态执行环境中执行这些内核态特权级指令，会产生异常。

为了让应用程序获得操作系统的函数服务，采用传统的函数调用方式（即通常的 ``call`` 和 ``ret`` 指令或指令组合）将会直接绕过硬件的特权级保护检查。为了解决这个问题， LoongArch 提供了新的机器指令：SYSCALL 指令和 ERTN 指令。其中：

-  ``syscall`` 具有用户态到内核态的执行环境切换能力的函数调用指令；
-  ``ertn`` ：具有内核态到用户态的执行环境切换能力的函数返回指令。

硬件具有了这样的机制后，还需要操作系统的配合才能最终完成对操作系统自身的保护。首先，操作系统需要提供相应的功能代码，能在执行 ``ertn`` 前准备和恢复用户态执行应用程序的上下文。其次，在应用程序调用 ``syscall`` 指令后，能够检查应用程序的系统调用参数，确保参数不会破坏操作系统。

.. _loongarch-priv-arch:

LoongArch 特权级架构
--------------------------------------

龙芯架构中处理器核分为 4 个特权等级（Privilege LeVel，简称 PLV），分别是 PLV0~PLV3。处理器核当前处于哪个特权等级由 CSR.CRMD 中 PLV 域的值唯一确定。

所有特权等级中，PLV0 是具有最高权限的特权等级，也是唯一可以使用特权指令并访问所有特权资源的特权等级。PLV1~PLV3 这三个特权等级，都不能执行特权指令访问特权资源，不过三个特权等级在 MMU 采用映射地址翻译模式下具有不同的访问权限。

对于 Linux 系统来说，架构中仅 PLV0 级可对应核心态，同时建议以 PLV3 级对应用户态。

之前我们给出过支持应用程序运行的一套 :ref:`执行环境栈 <app-software-stack>` ，现在我们站在特权级架构的角度去重新看待它：

.. image:: PrivilegeStack.png
   :align: center
   :name: PrivilegeStack

.. _term-see:

和之前一样，白色块表示一层执行环境，黑色块表示相邻两层执行环境之间的接口。这张图片给出了能够支持运行 Unix 这类复杂系统的软件栈。其中操作系统内核代码运行在 PLV0 上；应用程序运行在 PLV3 上。

与 RISC-V 不同，LoongArch 没有所谓的 M 模式，在 LoongArch 架构上的引导加载程序一般与操作系统一样运行在 PLV0 上。此外，编程语言相关的标准库也会在执行应用程序员编写的应用程序之前进行一些初始化工作。但在这张图中我们并没有将应用程序的执行环境详细展开，而是统一归类到 PLV3 软件，也就是应用程序中。

回顾第一章，当时只是实现了简单的支持单个裸机应用的库级别的“三叶虫”操作系统，它和应用程序全程运行在 PLV3 下，应用程序很容易破坏没有任何保护的执行环境--操作系统。而在后续的章节中，我们会涉及到 LoongArch 的 PLV0 和 PLV3 两种特权级：其中应用程序和用户态支持库运行在 PLV3 的最低特权级；操作系统内核运行在 PLV0 特权级（在本章表现为一个简单的批处理系统），形成支撑应用程序和用户态支持库的执行环境。整个软件系统就由这两层运行在不同特权级下的不同软件组成。

.. _term-trap:

执行环境的另一种功能是对上层软件的执行进行监控管理。监控管理可以理解为，当上层软件执行的时候出现了一些异常或特殊情况，导致需要用到执行环境中提供的功能，因此需要暂停上层软件的执行，转而运行执行环境的代码。由于上层软件和执行环境被设计为运行在不同的特权级，这个过程也往往（而 **不一定** ）伴随着 CPU 的 **特权级切换** 。当执行环境的代码运行结束后，我们需要回到上层软件暂停的位置继续执行。在 LoongArch 架构中，这种与常规控制流（顺序、循环、分支、函数调用）不同的 **异常控制流** (ECF, Exception Control Flow) 被称为 **异常（Exception）** 。

.. _term-exception:

用户态应用直接触发从用户态到内核态的异常的原因总体上可以分为两种：其一是用户态软件为获得内核态操作系统的服务功能而执行特殊指令；其二是在执行某条指令期间产生了错误（如执行了用户态不允许执行的指令或者其他错误）并被 CPU 检测到。
具体来说，在 LoongArch 架构中，从来源来看，异常可分为外部事件、指令执行中的错误、数据完整性问题、地址转换异常、系统调用和陷入、需要软件修正的运算六种。下表列举了 LoongArch 指令系统中主要的 **异常（也称为例外）**：

.. list-table:: **LoongArch 指令系统例外编码表**
    :align: center
    :header-rows: 1
    :widths: 20 10 20 60

    * - Ecode
      - EsubCode
      - 例外代号
      - 例外类型
    * - 0x0
      - 
      - INT
      - 仅当 CSR.ECFG.VS=0 时，表示是中断。
    * - 0x1
      - 
      - PIL
      - load 操作页无效例外
    * - 0x2
      - 
      - PIS
      - store 操作页无效例外
    * - 0x3
      - 
      - PIF
      - 取指操作页无效例外
    * - 0x4
      - 
      - PME
      - 页修改例外
    * - 0x5
      - 
      - PNR
      - 页不可读例外
    * - 0x6
      - 
      - PNX
      - 页不可执行例外
    * - 0x7
      - 
      - PPI
      - 页特权等级不合规例外
    * - 0x8
      - 0
      - ADEF
      - 取指地址错例外
    * - 0x8
      - 1
      - ADEM
      - 访存指令地址错例外
    * - 0x9
      - 
      - ALE
      - 地址非对齐例外
    * - 0xA
      - 
      - BCE
      - 边界检查错例外
    * - 0xB
      - 
      - SYS
      - 系统调用例外
    * - 0xC
      - 
      - BRK
      - 断点例外
    * - 0xD
      - 
      - INE
      - 指令不存在例外
    * - 0xE
      - 
      - IPE
      - 指令特权等级错例外
    * - 0xF
      - 
      - FPD
      - 浮点指令未使能例外
    * - 0x10
      - 
      - SXD
      - 128 位向量拓展指令未使能例外
    * - 0x11
      - 
      - ASXD
      - 256 位向量拓展指令未使能例外
    * - 0x12
      - 0
      - FPE
      - 基础浮点指令例外
    * - 0x12
      - 1
      - VFPE
      - 向量浮点指令例外
    * - 0x13
      - 0
      - WPEF
      - 取指监测点例外
    * - 0x13
      - 1
      - WPEM
      - load/store 操作监测点例外
    * - 0x14
      - 
      - BTD
      - 二进制翻译拓展指令未使能例外
    * - 0x15
      - 
      - BTE
      - 二进制翻译相关例外
    * - 0x16
      - 
      - GSPR
      - 客户机敏感特权资源例外
    * - 0x17
      - 
      - HVC
      - 虚拟机监控调用例外
    * - 0x18
      - 0
      - GCSC
      - 客户机 CSR 软件修改例外
    * - 0x18
      - 1
      - GCHC
      - 客户机 CSR 硬件修改例外
    * - 0x1A-0x3E
      - 
      - 
      - 保留编码





.. _term-environment-call:

其中 **断点** (Breakpoint) 和 **执行环境调用** (Environment call) 两种异常（为了与其他非有意为之的异常区分，会把这种有意为之的指令称为 *陷入* 或 *trap* 类指令，此处的陷入为操作系统中传统概念）是通过在上层软件中执行一条特定的指令触发的：执行 ``break`` 这条指令之后就会触发断点陷入异常；而执行 ``syscall`` 这条指令时候则会触发系统调用异常。

.. _term-sbi:
.. _term-abi:

在这里我们需要说明一下执行环境调用 ``syscall`` ，这是一种很特殊的 *陷入* 类的指令， :ref:`上图 <PrivilegeStack>` 中相邻两特权级软件之间的接口正是基于这种陷入机制实现的。内核和 PLV3 的应用程序之间的接口被称为 **应用程序二进制接口** (Application Binary Interface, ABI)，当然它有一个更加通俗的名字—— **系统调用** (syscall, System Call) 。而之所以叫做二进制接口，是因为它与高级编程语言的内部调用接口不同，是机器/汇编指令级的一种接口。事实上 PLV0 和 PLV3 两个特权级的软件可分别由不同的编程语言实现，即使是用同一种编程语言实现的，其调用也并不是普通的函数调用控制流，而是 **陷入异常控制流** ，在该过程中会切换 CPU 特权级。因此只有将接口下降到机器/汇编指令级才能够满足其跨高级语言的通用性和灵活性。

可以看到，在这样的架构之下，每层特权级的软件都只能做高特权级软件允许它做的、且不会产生什么撼动高特权级软件的事情，一旦低特权级软件的要求超出了其能力范围，就必须寻求高特权级软件的帮助，否则就是一种异常行为了。因此，在软件（应用、操作系统等）执行过程中我们经常能够看到特权级切换。如下图所示：

.. image:: EnvironmentCallFlow.png
   :align: center
   :name: environment-call-flow

.. _term-csr:

其他的异常则一般是在执行某一条指令的时候发生了某种错误（如除零、无效地址访问、无效指令等），或处理器认为处于当前特权级下执行的当前指令是高特权级指令或会访问不应该访问的高特权级的资源（可能危害系统）。碰到这些情况，就需要将控制转交给高特权级的软件（如操作系统）来处理。当错误/异常恢复后，则可重新回到低优先级软件去执行；如果不能恢复错误/异常，那高特权级软件可以杀死和清除低特权级软件，避免破坏整个执行环境。

.. _term-csr-instr:

LoongArch 的特权指令
^^^^^^^^^^^^^^^^^^^^^^^^^

与特权级无关的一般的指令和通用寄存器 ``x0`` ~ ``x31`` 在任何特权级都可以执行。而每个特权级都对应一些特殊指令和 **控制状态寄存器** (CSR, Control and Status Register) ，来控制该特权级的某些行为并描述其状态。当然特权指令不仅具有读写 CSR 的指令，还有其他功能的特权指令。

如果处于低特权级状态的处理器执行了高特权级的指令，会产生非法指令错误的异常。这样，位于高特权级的执行环境能够得知低特权级的软件出现了错误，这个错误一般是不可恢复的，此时执行环境会将低特权级的软件终止。这在某种程度上体现了特权级保护机制的作用。

在 LoongArch 中，会有两类属于高特权级 PLV0 模式的特权指令：

- 指令本身属于高特权级的指令，如 ``ertn`` 指令（表示从 PLV0 模式返回到 PLV3 模式）。
- 指令访问了 :ref:`PLV0 模式特权级下才能访问的寄存器 <term-s-mod-csr>` 或内存，如表示 PLV0 模式系统状态的 **控制状态寄存器** ``prmd`` 等。

具体来说，分为以下六类：

- CSR 访问指令
- IOCSR 访问指令
- Cache 维护指令
- TLB 维护指令
- 软件页表遍历指令
- 其它杂项指令

要具体了解 LoongArch 的特权指令，请参考 `龙芯架构参考手册 <https://github.com/Helloworld-lbl/LoongArch-Documents/blob/main/%E9%BE%99%E8%8A%AF%E6%9E%B6%E6%9E%84%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%E5%8D%B7%E4%B8%80.pdf>`_ 的第 4 章。

.. .. list-table:: LoongArch PLV0 模式特权指令
..    :align: center
..    :header-rows: 1
..    :widths: 30 60

..    * - 指令
..      - 含义
..    * - sret
..      - 从 S 模式返回 U 模式：在 U 模式下执行会产生非法指令异常
..    * - wfi
..      - 处理器在空闲时进入低功耗状态等待中断：在 U 模式下执行会产生非法指令异常
..    * - sfence.vma
..      - 刷新 TLB 缓存：在 U 模式下执行会产生非法指令异常     
..    * - 访问 S 模式 CSR 的指令
..      - 通过访问 :ref:`sepc/stvec/scause/sscartch/stval/sstatus/satp等CSR <term-s-mod-csr>` 来改变系统状态：在 U 模式下执行会产生非法指令异常

在下一节中，我们将看到 :ref:`在 PLV3 模式下运行的用户态应用程序 <term-csr-instr-app>` ，如果执行上述 PLV0 模式特权指令，将会产生非法指令异常，从而看出 LoongArch 的特权模式提供了对操作系统一定程度的保护。

.. 
   * - mret
     - 从M模式返回S/U模式。在S/U模式下执行会产生非法指令异常
   随着特权级的逐渐降低，硬件的能力受到限制，
   从每一个特权级看来，比它特权级更低的部分都可以看成是它的应用。（这个好像没啥用？）
   M 模式是每个 RISC-V CPU 都需要实现的模式，而剩下的模式都是可选的。常见的模式组合：普通嵌入式应用只需要在 M 模式上运行；追求安全的
   嵌入式应用需要在 M/U 模式上运行；像 Unix 这样比较复杂的系统这需要 M/S/U 三种模式。
   RISC-V 特权级规范中给出了一些特权寄存器和特权指令...
   重要的是保护，也就是特权级的切换。当 CPU 处于低特权级的时候，如果发生了错误或者一些需要处理的情况，CPU 会切换到高特权级进行处理。这个
   就是所谓的 Trap 机制。
   RISC-V 架构规范分为两部分： `RISC-V 无特权级规范 <https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf>`_ 
   和 `RISC-V 特权级规范 <https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf>`_ 。
   RISC-V 无特权级规范中给出的指令和寄存器无论在 CPU 处于哪个特权级下都可以使用。